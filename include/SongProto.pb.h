// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SongProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SongProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SongProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SongProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SongProto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SongProto_2eproto;
namespace SongDetailsCache {
namespace Structs {
class SongDetailsV3;
struct SongDetailsV3DefaultTypeInternal;
extern SongDetailsV3DefaultTypeInternal _SongDetailsV3_default_instance_;
class SongDifficulty;
struct SongDifficultyDefaultTypeInternal;
extern SongDifficultyDefaultTypeInternal _SongDifficulty_default_instance_;
class SongV3;
struct SongV3DefaultTypeInternal;
extern SongV3DefaultTypeInternal _SongV3_default_instance_;
}  // namespace Structs
}  // namespace SongDetailsCache
PROTOBUF_NAMESPACE_OPEN
template<> ::SongDetailsCache::Structs::SongDetailsV3* Arena::CreateMaybeMessage<::SongDetailsCache::Structs::SongDetailsV3>(Arena*);
template<> ::SongDetailsCache::Structs::SongDifficulty* Arena::CreateMaybeMessage<::SongDetailsCache::Structs::SongDifficulty>(Arena*);
template<> ::SongDetailsCache::Structs::SongV3* Arena::CreateMaybeMessage<::SongDetailsCache::Structs::SongV3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SongDetailsCache {
namespace Structs {

enum SongDifficulty_MapCharacteristic : int {
  SongDifficulty_MapCharacteristic_Custom = 0,
  SongDifficulty_MapCharacteristic_Standard = 1,
  SongDifficulty_MapCharacteristic_OneSaber = 2,
  SongDifficulty_MapCharacteristic_NoArrows = 3,
  SongDifficulty_MapCharacteristic_NinetyDegree = 4,
  SongDifficulty_MapCharacteristic_ThreeSixtyDegree = 5,
  SongDifficulty_MapCharacteristic_Lightshow = 6,
  SongDifficulty_MapCharacteristic_Lawless = 7,
  SongDifficulty_MapCharacteristic_SongDifficulty_MapCharacteristic_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SongDifficulty_MapCharacteristic_SongDifficulty_MapCharacteristic_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SongDifficulty_MapCharacteristic_IsValid(int value);
constexpr SongDifficulty_MapCharacteristic SongDifficulty_MapCharacteristic_MapCharacteristic_MIN = SongDifficulty_MapCharacteristic_Custom;
constexpr SongDifficulty_MapCharacteristic SongDifficulty_MapCharacteristic_MapCharacteristic_MAX = SongDifficulty_MapCharacteristic_Lawless;
constexpr int SongDifficulty_MapCharacteristic_MapCharacteristic_ARRAYSIZE = SongDifficulty_MapCharacteristic_MapCharacteristic_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongDifficulty_MapCharacteristic_descriptor();
template<typename T>
inline const std::string& SongDifficulty_MapCharacteristic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SongDifficulty_MapCharacteristic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SongDifficulty_MapCharacteristic_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SongDifficulty_MapCharacteristic_descriptor(), enum_t_value);
}
inline bool SongDifficulty_MapCharacteristic_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SongDifficulty_MapCharacteristic* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SongDifficulty_MapCharacteristic>(
    SongDifficulty_MapCharacteristic_descriptor(), name, value);
}
enum SongDifficulty_MapDifficulty : int {
  SongDifficulty_MapDifficulty_Easy = 0,
  SongDifficulty_MapDifficulty_Normal = 1,
  SongDifficulty_MapDifficulty_Hard = 2,
  SongDifficulty_MapDifficulty_Expert = 3,
  SongDifficulty_MapDifficulty_ExpertPlus = 4,
  SongDifficulty_MapDifficulty_SongDifficulty_MapDifficulty_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SongDifficulty_MapDifficulty_SongDifficulty_MapDifficulty_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SongDifficulty_MapDifficulty_IsValid(int value);
constexpr SongDifficulty_MapDifficulty SongDifficulty_MapDifficulty_MapDifficulty_MIN = SongDifficulty_MapDifficulty_Easy;
constexpr SongDifficulty_MapDifficulty SongDifficulty_MapDifficulty_MapDifficulty_MAX = SongDifficulty_MapDifficulty_ExpertPlus;
constexpr int SongDifficulty_MapDifficulty_MapDifficulty_ARRAYSIZE = SongDifficulty_MapDifficulty_MapDifficulty_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongDifficulty_MapDifficulty_descriptor();
template<typename T>
inline const std::string& SongDifficulty_MapDifficulty_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SongDifficulty_MapDifficulty>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SongDifficulty_MapDifficulty_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SongDifficulty_MapDifficulty_descriptor(), enum_t_value);
}
inline bool SongDifficulty_MapDifficulty_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SongDifficulty_MapDifficulty* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SongDifficulty_MapDifficulty>(
    SongDifficulty_MapDifficulty_descriptor(), name, value);
}
enum RankedStatusBitflags : int {
  Unranked = 0,
  RankedSS = 1,
  RankedBL = 2,
  QualifiedSS = 4,
  QualifiedBL = 8,
  RankedStatusBitflags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RankedStatusBitflags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RankedStatusBitflags_IsValid(int value);
constexpr RankedStatusBitflags RankedStatusBitflags_MIN = Unranked;
constexpr RankedStatusBitflags RankedStatusBitflags_MAX = QualifiedBL;
constexpr int RankedStatusBitflags_ARRAYSIZE = RankedStatusBitflags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RankedStatusBitflags_descriptor();
template<typename T>
inline const std::string& RankedStatusBitflags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RankedStatusBitflags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RankedStatusBitflags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RankedStatusBitflags_descriptor(), enum_t_value);
}
inline bool RankedStatusBitflags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RankedStatusBitflags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RankedStatusBitflags>(
    RankedStatusBitflags_descriptor(), name, value);
}
enum UploadFlags : int {
  None = 0,
  CuratedMap = 1,
  VerifiedUploader = 2,
  HasV3Environment = 4,
  UploadFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UploadFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UploadFlags_IsValid(int value);
constexpr UploadFlags UploadFlags_MIN = None;
constexpr UploadFlags UploadFlags_MAX = HasV3Environment;
constexpr int UploadFlags_ARRAYSIZE = UploadFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UploadFlags_descriptor();
template<typename T>
inline const std::string& UploadFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UploadFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UploadFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UploadFlags_descriptor(), enum_t_value);
}
inline bool UploadFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UploadFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UploadFlags>(
    UploadFlags_descriptor(), name, value);
}
// ===================================================================

class SongDetailsV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SongDetailsCache.Structs.SongDetailsV3) */ {
 public:
  inline SongDetailsV3() : SongDetailsV3(nullptr) {}
  ~SongDetailsV3() override;
  explicit PROTOBUF_CONSTEXPR SongDetailsV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongDetailsV3(const SongDetailsV3& from);
  SongDetailsV3(SongDetailsV3&& from) noexcept
    : SongDetailsV3() {
    *this = ::std::move(from);
  }

  inline SongDetailsV3& operator=(const SongDetailsV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongDetailsV3& operator=(SongDetailsV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongDetailsV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongDetailsV3* internal_default_instance() {
    return reinterpret_cast<const SongDetailsV3*>(
               &_SongDetailsV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SongDetailsV3& a, SongDetailsV3& b) {
    a.Swap(&b);
  }
  inline void Swap(SongDetailsV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongDetailsV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongDetailsV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongDetailsV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongDetailsV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongDetailsV3& from) {
    SongDetailsV3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongDetailsV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SongDetailsCache.Structs.SongDetailsV3";
  }
  protected:
  explicit SongDetailsV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongsFieldNumber = 4,
    kTagListFieldNumber = 5,
    kSongHashesFieldNumber = 3,
    kFormatVersionFieldNumber = 1,
    kScrapeEndedUnixFieldNumber = 2,
  };
  // repeated .SongDetailsCache.Structs.SongV3 songs = 4;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  ::SongDetailsCache::Structs::SongV3* mutable_songs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongV3 >*
      mutable_songs();
  private:
  const ::SongDetailsCache::Structs::SongV3& _internal_songs(int index) const;
  ::SongDetailsCache::Structs::SongV3* _internal_add_songs();
  public:
  const ::SongDetailsCache::Structs::SongV3& songs(int index) const;
  ::SongDetailsCache::Structs::SongV3* add_songs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongV3 >&
      songs() const;

  // repeated string tagList = 5;
  int taglist_size() const;
  private:
  int _internal_taglist_size() const;
  public:
  void clear_taglist();
  const std::string& taglist(int index) const;
  std::string* mutable_taglist(int index);
  void set_taglist(int index, const std::string& value);
  void set_taglist(int index, std::string&& value);
  void set_taglist(int index, const char* value);
  void set_taglist(int index, const char* value, size_t size);
  std::string* add_taglist();
  void add_taglist(const std::string& value);
  void add_taglist(std::string&& value);
  void add_taglist(const char* value);
  void add_taglist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& taglist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_taglist();
  private:
  const std::string& _internal_taglist(int index) const;
  std::string* _internal_add_taglist();
  public:

  // bytes songHashes = 3;
  void clear_songhashes();
  const std::string& songhashes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_songhashes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_songhashes();
  PROTOBUF_NODISCARD std::string* release_songhashes();
  void set_allocated_songhashes(std::string* songhashes);
  private:
  const std::string& _internal_songhashes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_songhashes(const std::string& value);
  std::string* _internal_mutable_songhashes();
  public:

  // uint32 formatVersion = 1;
  void clear_formatversion();
  uint32_t formatversion() const;
  void set_formatversion(uint32_t value);
  private:
  uint32_t _internal_formatversion() const;
  void _internal_set_formatversion(uint32_t value);
  public:

  // uint32 scrapeEndedUnix = 2;
  void clear_scrapeendedunix();
  uint32_t scrapeendedunix() const;
  void set_scrapeendedunix(uint32_t value);
  private:
  uint32_t _internal_scrapeendedunix() const;
  void _internal_set_scrapeendedunix(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SongDetailsCache.Structs.SongDetailsV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongV3 > songs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> taglist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr songhashes_;
    uint32_t formatversion_;
    uint32_t scrapeendedunix_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SongProto_2eproto;
};
// -------------------------------------------------------------------

class SongV3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SongDetailsCache.Structs.SongV3) */ {
 public:
  inline SongV3() : SongV3(nullptr) {}
  ~SongV3() override;
  explicit PROTOBUF_CONSTEXPR SongV3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongV3(const SongV3& from);
  SongV3(SongV3&& from) noexcept
    : SongV3() {
    *this = ::std::move(from);
  }

  inline SongV3& operator=(const SongV3& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongV3& operator=(SongV3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongV3& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongV3* internal_default_instance() {
    return reinterpret_cast<const SongV3*>(
               &_SongV3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SongV3& a, SongV3& b) {
    a.Swap(&b);
  }
  inline void Swap(SongV3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongV3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongV3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongV3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongV3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongV3& from) {
    SongV3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongV3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SongDetailsCache.Structs.SongV3";
  }
  protected:
  explicit SongV3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDifficultiesFieldNumber = 11,
    kSongNameFieldNumber = 7,
    kSongAuthorNameFieldNumber = 8,
    kLevelAuthorNameFieldNumber = 9,
    kUploaderNameFieldNumber = 10,
    kBpmFieldNumber = 1,
    kUpvotesFieldNumber = 2,
    kDownvotesFieldNumber = 3,
    kUploadTimeUnixFieldNumber = 4,
    kMapIdFieldNumber = 5,
    kSongDurationSecondsFieldNumber = 6,
    kRankedChangeUnixFieldNumber = 12,
    kRankedStateBitflagsFieldNumber = 13,
    kTagsFieldNumber = 14,
    kUploadFlagsFieldNumber = 15,
  };
  // repeated .SongDetailsCache.Structs.SongDifficulty difficulties = 11;
  int difficulties_size() const;
  private:
  int _internal_difficulties_size() const;
  public:
  void clear_difficulties();
  ::SongDetailsCache::Structs::SongDifficulty* mutable_difficulties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongDifficulty >*
      mutable_difficulties();
  private:
  const ::SongDetailsCache::Structs::SongDifficulty& _internal_difficulties(int index) const;
  ::SongDetailsCache::Structs::SongDifficulty* _internal_add_difficulties();
  public:
  const ::SongDetailsCache::Structs::SongDifficulty& difficulties(int index) const;
  ::SongDetailsCache::Structs::SongDifficulty* add_difficulties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongDifficulty >&
      difficulties() const;

  // string songName = 7;
  void clear_songname();
  const std::string& songname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_songname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_songname();
  PROTOBUF_NODISCARD std::string* release_songname();
  void set_allocated_songname(std::string* songname);
  private:
  const std::string& _internal_songname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_songname(const std::string& value);
  std::string* _internal_mutable_songname();
  public:

  // string songAuthorName = 8;
  void clear_songauthorname();
  const std::string& songauthorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_songauthorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_songauthorname();
  PROTOBUF_NODISCARD std::string* release_songauthorname();
  void set_allocated_songauthorname(std::string* songauthorname);
  private:
  const std::string& _internal_songauthorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_songauthorname(const std::string& value);
  std::string* _internal_mutable_songauthorname();
  public:

  // string levelAuthorName = 9;
  void clear_levelauthorname();
  const std::string& levelauthorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_levelauthorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_levelauthorname();
  PROTOBUF_NODISCARD std::string* release_levelauthorname();
  void set_allocated_levelauthorname(std::string* levelauthorname);
  private:
  const std::string& _internal_levelauthorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_levelauthorname(const std::string& value);
  std::string* _internal_mutable_levelauthorname();
  public:

  // optional string uploaderName = 10;
  bool has_uploadername() const;
  private:
  bool _internal_has_uploadername() const;
  public:
  void clear_uploadername();
  const std::string& uploadername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uploadername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uploadername();
  PROTOBUF_NODISCARD std::string* release_uploadername();
  void set_allocated_uploadername(std::string* uploadername);
  private:
  const std::string& _internal_uploadername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uploadername(const std::string& value);
  std::string* _internal_mutable_uploadername();
  public:

  // float bpm = 1;
  void clear_bpm();
  float bpm() const;
  void set_bpm(float value);
  private:
  float _internal_bpm() const;
  void _internal_set_bpm(float value);
  public:

  // optional uint32 upvotes = 2;
  bool has_upvotes() const;
  private:
  bool _internal_has_upvotes() const;
  public:
  void clear_upvotes();
  uint32_t upvotes() const;
  void set_upvotes(uint32_t value);
  private:
  uint32_t _internal_upvotes() const;
  void _internal_set_upvotes(uint32_t value);
  public:

  // optional uint32 downvotes = 3;
  bool has_downvotes() const;
  private:
  bool _internal_has_downvotes() const;
  public:
  void clear_downvotes();
  uint32_t downvotes() const;
  void set_downvotes(uint32_t value);
  private:
  uint32_t _internal_downvotes() const;
  void _internal_set_downvotes(uint32_t value);
  public:

  // uint32 uploadTimeUnix = 4;
  void clear_uploadtimeunix();
  uint32_t uploadtimeunix() const;
  void set_uploadtimeunix(uint32_t value);
  private:
  uint32_t _internal_uploadtimeunix() const;
  void _internal_set_uploadtimeunix(uint32_t value);
  public:

  // uint32 mapId = 5;
  void clear_mapid();
  uint32_t mapid() const;
  void set_mapid(uint32_t value);
  private:
  uint32_t _internal_mapid() const;
  void _internal_set_mapid(uint32_t value);
  public:

  // optional uint32 songDurationSeconds = 6;
  bool has_songdurationseconds() const;
  private:
  bool _internal_has_songdurationseconds() const;
  public:
  void clear_songdurationseconds();
  uint32_t songdurationseconds() const;
  void set_songdurationseconds(uint32_t value);
  private:
  uint32_t _internal_songdurationseconds() const;
  void _internal_set_songdurationseconds(uint32_t value);
  public:

  // optional uint32 rankedChangeUnix = 12;
  bool has_rankedchangeunix() const;
  private:
  bool _internal_has_rankedchangeunix() const;
  public:
  void clear_rankedchangeunix();
  uint32_t rankedchangeunix() const;
  void set_rankedchangeunix(uint32_t value);
  private:
  uint32_t _internal_rankedchangeunix() const;
  void _internal_set_rankedchangeunix(uint32_t value);
  public:

  // optional .SongDetailsCache.Structs.RankedStatusBitflags rankedStateBitflags = 13;
  bool has_rankedstatebitflags() const;
  private:
  bool _internal_has_rankedstatebitflags() const;
  public:
  void clear_rankedstatebitflags();
  ::SongDetailsCache::Structs::RankedStatusBitflags rankedstatebitflags() const;
  void set_rankedstatebitflags(::SongDetailsCache::Structs::RankedStatusBitflags value);
  private:
  ::SongDetailsCache::Structs::RankedStatusBitflags _internal_rankedstatebitflags() const;
  void _internal_set_rankedstatebitflags(::SongDetailsCache::Structs::RankedStatusBitflags value);
  public:

  // optional uint64 tags = 14;
  bool has_tags() const;
  private:
  bool _internal_has_tags() const;
  public:
  void clear_tags();
  uint64_t tags() const;
  void set_tags(uint64_t value);
  private:
  uint64_t _internal_tags() const;
  void _internal_set_tags(uint64_t value);
  public:

  // optional .SongDetailsCache.Structs.UploadFlags uploadFlags = 15;
  bool has_uploadflags() const;
  private:
  bool _internal_has_uploadflags() const;
  public:
  void clear_uploadflags();
  ::SongDetailsCache::Structs::UploadFlags uploadflags() const;
  void set_uploadflags(::SongDetailsCache::Structs::UploadFlags value);
  private:
  ::SongDetailsCache::Structs::UploadFlags _internal_uploadflags() const;
  void _internal_set_uploadflags(::SongDetailsCache::Structs::UploadFlags value);
  public:

  // @@protoc_insertion_point(class_scope:SongDetailsCache.Structs.SongV3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongDifficulty > difficulties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr songname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr songauthorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr levelauthorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uploadername_;
    float bpm_;
    uint32_t upvotes_;
    uint32_t downvotes_;
    uint32_t uploadtimeunix_;
    uint32_t mapid_;
    uint32_t songdurationseconds_;
    uint32_t rankedchangeunix_;
    int rankedstatebitflags_;
    uint64_t tags_;
    int uploadflags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SongProto_2eproto;
};
// -------------------------------------------------------------------

class SongDifficulty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SongDetailsCache.Structs.SongDifficulty) */ {
 public:
  inline SongDifficulty() : SongDifficulty(nullptr) {}
  ~SongDifficulty() override;
  explicit PROTOBUF_CONSTEXPR SongDifficulty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongDifficulty(const SongDifficulty& from);
  SongDifficulty(SongDifficulty&& from) noexcept
    : SongDifficulty() {
    *this = ::std::move(from);
  }

  inline SongDifficulty& operator=(const SongDifficulty& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongDifficulty& operator=(SongDifficulty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongDifficulty& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongDifficulty* internal_default_instance() {
    return reinterpret_cast<const SongDifficulty*>(
               &_SongDifficulty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SongDifficulty& a, SongDifficulty& b) {
    a.Swap(&b);
  }
  inline void Swap(SongDifficulty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongDifficulty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongDifficulty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongDifficulty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongDifficulty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongDifficulty& from) {
    SongDifficulty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongDifficulty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SongDetailsCache.Structs.SongDifficulty";
  }
  protected:
  explicit SongDifficulty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SongDifficulty_MapCharacteristic MapCharacteristic;
  static constexpr MapCharacteristic Custom =
    SongDifficulty_MapCharacteristic_Custom;
  static constexpr MapCharacteristic Standard =
    SongDifficulty_MapCharacteristic_Standard;
  static constexpr MapCharacteristic OneSaber =
    SongDifficulty_MapCharacteristic_OneSaber;
  static constexpr MapCharacteristic NoArrows =
    SongDifficulty_MapCharacteristic_NoArrows;
  static constexpr MapCharacteristic NinetyDegree =
    SongDifficulty_MapCharacteristic_NinetyDegree;
  static constexpr MapCharacteristic ThreeSixtyDegree =
    SongDifficulty_MapCharacteristic_ThreeSixtyDegree;
  static constexpr MapCharacteristic Lightshow =
    SongDifficulty_MapCharacteristic_Lightshow;
  static constexpr MapCharacteristic Lawless =
    SongDifficulty_MapCharacteristic_Lawless;
  static inline bool MapCharacteristic_IsValid(int value) {
    return SongDifficulty_MapCharacteristic_IsValid(value);
  }
  static constexpr MapCharacteristic MapCharacteristic_MIN =
    SongDifficulty_MapCharacteristic_MapCharacteristic_MIN;
  static constexpr MapCharacteristic MapCharacteristic_MAX =
    SongDifficulty_MapCharacteristic_MapCharacteristic_MAX;
  static constexpr int MapCharacteristic_ARRAYSIZE =
    SongDifficulty_MapCharacteristic_MapCharacteristic_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MapCharacteristic_descriptor() {
    return SongDifficulty_MapCharacteristic_descriptor();
  }
  template<typename T>
  static inline const std::string& MapCharacteristic_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MapCharacteristic>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MapCharacteristic_Name.");
    return SongDifficulty_MapCharacteristic_Name(enum_t_value);
  }
  static inline bool MapCharacteristic_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MapCharacteristic* value) {
    return SongDifficulty_MapCharacteristic_Parse(name, value);
  }

  typedef SongDifficulty_MapDifficulty MapDifficulty;
  static constexpr MapDifficulty Easy =
    SongDifficulty_MapDifficulty_Easy;
  static constexpr MapDifficulty Normal =
    SongDifficulty_MapDifficulty_Normal;
  static constexpr MapDifficulty Hard =
    SongDifficulty_MapDifficulty_Hard;
  static constexpr MapDifficulty Expert =
    SongDifficulty_MapDifficulty_Expert;
  static constexpr MapDifficulty ExpertPlus =
    SongDifficulty_MapDifficulty_ExpertPlus;
  static inline bool MapDifficulty_IsValid(int value) {
    return SongDifficulty_MapDifficulty_IsValid(value);
  }
  static constexpr MapDifficulty MapDifficulty_MIN =
    SongDifficulty_MapDifficulty_MapDifficulty_MIN;
  static constexpr MapDifficulty MapDifficulty_MAX =
    SongDifficulty_MapDifficulty_MapDifficulty_MAX;
  static constexpr int MapDifficulty_ARRAYSIZE =
    SongDifficulty_MapDifficulty_MapDifficulty_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MapDifficulty_descriptor() {
    return SongDifficulty_MapDifficulty_descriptor();
  }
  template<typename T>
  static inline const std::string& MapDifficulty_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MapDifficulty>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MapDifficulty_Name.");
    return SongDifficulty_MapDifficulty_Name(enum_t_value);
  }
  static inline bool MapDifficulty_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MapDifficulty* value) {
    return SongDifficulty_MapDifficulty_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCharacteristicFieldNumber = 1,
    kDifficultyFieldNumber = 2,
    kStarsT100FieldNumber = 4,
    kStarsT100BLFieldNumber = 5,
    kNjsT100FieldNumber = 6,
    kBombsFieldNumber = 7,
    kNotesFieldNumber = 8,
    kObstaclesFieldNumber = 9,
    kModsFieldNumber = 10,
  };
  // optional .SongDetailsCache.Structs.SongDifficulty.MapCharacteristic characteristic = 1;
  bool has_characteristic() const;
  private:
  bool _internal_has_characteristic() const;
  public:
  void clear_characteristic();
  ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic characteristic() const;
  void set_characteristic(::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic value);
  private:
  ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic _internal_characteristic() const;
  void _internal_set_characteristic(::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic value);
  public:

  // optional .SongDetailsCache.Structs.SongDifficulty.MapDifficulty difficulty = 2;
  bool has_difficulty() const;
  private:
  bool _internal_has_difficulty() const;
  public:
  void clear_difficulty();
  ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty difficulty() const;
  void set_difficulty(::SongDetailsCache::Structs::SongDifficulty_MapDifficulty value);
  private:
  ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty _internal_difficulty() const;
  void _internal_set_difficulty(::SongDetailsCache::Structs::SongDifficulty_MapDifficulty value);
  public:

  // optional uint32 starsT100 = 4;
  bool has_starst100() const;
  private:
  bool _internal_has_starst100() const;
  public:
  void clear_starst100();
  uint32_t starst100() const;
  void set_starst100(uint32_t value);
  private:
  uint32_t _internal_starst100() const;
  void _internal_set_starst100(uint32_t value);
  public:

  // optional uint32 starsT100BL = 5;
  bool has_starst100bl() const;
  private:
  bool _internal_has_starst100bl() const;
  public:
  void clear_starst100bl();
  uint32_t starst100bl() const;
  void set_starst100bl(uint32_t value);
  private:
  uint32_t _internal_starst100bl() const;
  void _internal_set_starst100bl(uint32_t value);
  public:

  // uint32 njsT100 = 6;
  void clear_njst100();
  uint32_t njst100() const;
  void set_njst100(uint32_t value);
  private:
  uint32_t _internal_njst100() const;
  void _internal_set_njst100(uint32_t value);
  public:

  // optional uint32 bombs = 7;
  bool has_bombs() const;
  private:
  bool _internal_has_bombs() const;
  public:
  void clear_bombs();
  uint32_t bombs() const;
  void set_bombs(uint32_t value);
  private:
  uint32_t _internal_bombs() const;
  void _internal_set_bombs(uint32_t value);
  public:

  // optional uint32 notes = 8;
  bool has_notes() const;
  private:
  bool _internal_has_notes() const;
  public:
  void clear_notes();
  uint32_t notes() const;
  void set_notes(uint32_t value);
  private:
  uint32_t _internal_notes() const;
  void _internal_set_notes(uint32_t value);
  public:

  // optional uint32 obstacles = 9;
  bool has_obstacles() const;
  private:
  bool _internal_has_obstacles() const;
  public:
  void clear_obstacles();
  uint32_t obstacles() const;
  void set_obstacles(uint32_t value);
  private:
  uint32_t _internal_obstacles() const;
  void _internal_set_obstacles(uint32_t value);
  public:

  // optional uint32 mods = 10;
  bool has_mods() const;
  private:
  bool _internal_has_mods() const;
  public:
  void clear_mods();
  uint32_t mods() const;
  void set_mods(uint32_t value);
  private:
  uint32_t _internal_mods() const;
  void _internal_set_mods(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SongDetailsCache.Structs.SongDifficulty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int characteristic_;
    int difficulty_;
    uint32_t starst100_;
    uint32_t starst100bl_;
    uint32_t njst100_;
    uint32_t bombs_;
    uint32_t notes_;
    uint32_t obstacles_;
    uint32_t mods_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SongProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SongDetailsV3

// uint32 formatVersion = 1;
inline void SongDetailsV3::clear_formatversion() {
  _impl_.formatversion_ = 0u;
}
inline uint32_t SongDetailsV3::_internal_formatversion() const {
  return _impl_.formatversion_;
}
inline uint32_t SongDetailsV3::formatversion() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDetailsV3.formatVersion)
  return _internal_formatversion();
}
inline void SongDetailsV3::_internal_set_formatversion(uint32_t value) {
  
  _impl_.formatversion_ = value;
}
inline void SongDetailsV3::set_formatversion(uint32_t value) {
  _internal_set_formatversion(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDetailsV3.formatVersion)
}

// uint32 scrapeEndedUnix = 2;
inline void SongDetailsV3::clear_scrapeendedunix() {
  _impl_.scrapeendedunix_ = 0u;
}
inline uint32_t SongDetailsV3::_internal_scrapeendedunix() const {
  return _impl_.scrapeendedunix_;
}
inline uint32_t SongDetailsV3::scrapeendedunix() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDetailsV3.scrapeEndedUnix)
  return _internal_scrapeendedunix();
}
inline void SongDetailsV3::_internal_set_scrapeendedunix(uint32_t value) {
  
  _impl_.scrapeendedunix_ = value;
}
inline void SongDetailsV3::set_scrapeendedunix(uint32_t value) {
  _internal_set_scrapeendedunix(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDetailsV3.scrapeEndedUnix)
}

// bytes songHashes = 3;
inline void SongDetailsV3::clear_songhashes() {
  _impl_.songhashes_.ClearToEmpty();
}
inline const std::string& SongDetailsV3::songhashes() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDetailsV3.songHashes)
  return _internal_songhashes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongDetailsV3::set_songhashes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.songhashes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDetailsV3.songHashes)
}
inline std::string* SongDetailsV3::mutable_songhashes() {
  std::string* _s = _internal_mutable_songhashes();
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongDetailsV3.songHashes)
  return _s;
}
inline const std::string& SongDetailsV3::_internal_songhashes() const {
  return _impl_.songhashes_.Get();
}
inline void SongDetailsV3::_internal_set_songhashes(const std::string& value) {
  
  _impl_.songhashes_.Set(value, GetArenaForAllocation());
}
inline std::string* SongDetailsV3::_internal_mutable_songhashes() {
  
  return _impl_.songhashes_.Mutable(GetArenaForAllocation());
}
inline std::string* SongDetailsV3::release_songhashes() {
  // @@protoc_insertion_point(field_release:SongDetailsCache.Structs.SongDetailsV3.songHashes)
  return _impl_.songhashes_.Release();
}
inline void SongDetailsV3::set_allocated_songhashes(std::string* songhashes) {
  if (songhashes != nullptr) {
    
  } else {
    
  }
  _impl_.songhashes_.SetAllocated(songhashes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.songhashes_.IsDefault()) {
    _impl_.songhashes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SongDetailsCache.Structs.SongDetailsV3.songHashes)
}

// repeated .SongDetailsCache.Structs.SongV3 songs = 4;
inline int SongDetailsV3::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int SongDetailsV3::songs_size() const {
  return _internal_songs_size();
}
inline void SongDetailsV3::clear_songs() {
  _impl_.songs_.Clear();
}
inline ::SongDetailsCache::Structs::SongV3* SongDetailsV3::mutable_songs(int index) {
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongDetailsV3.songs)
  return _impl_.songs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongV3 >*
SongDetailsV3::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:SongDetailsCache.Structs.SongDetailsV3.songs)
  return &_impl_.songs_;
}
inline const ::SongDetailsCache::Structs::SongV3& SongDetailsV3::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline const ::SongDetailsCache::Structs::SongV3& SongDetailsV3::songs(int index) const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDetailsV3.songs)
  return _internal_songs(index);
}
inline ::SongDetailsCache::Structs::SongV3* SongDetailsV3::_internal_add_songs() {
  return _impl_.songs_.Add();
}
inline ::SongDetailsCache::Structs::SongV3* SongDetailsV3::add_songs() {
  ::SongDetailsCache::Structs::SongV3* _add = _internal_add_songs();
  // @@protoc_insertion_point(field_add:SongDetailsCache.Structs.SongDetailsV3.songs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongV3 >&
SongDetailsV3::songs() const {
  // @@protoc_insertion_point(field_list:SongDetailsCache.Structs.SongDetailsV3.songs)
  return _impl_.songs_;
}

// repeated string tagList = 5;
inline int SongDetailsV3::_internal_taglist_size() const {
  return _impl_.taglist_.size();
}
inline int SongDetailsV3::taglist_size() const {
  return _internal_taglist_size();
}
inline void SongDetailsV3::clear_taglist() {
  _impl_.taglist_.Clear();
}
inline std::string* SongDetailsV3::add_taglist() {
  std::string* _s = _internal_add_taglist();
  // @@protoc_insertion_point(field_add_mutable:SongDetailsCache.Structs.SongDetailsV3.tagList)
  return _s;
}
inline const std::string& SongDetailsV3::_internal_taglist(int index) const {
  return _impl_.taglist_.Get(index);
}
inline const std::string& SongDetailsV3::taglist(int index) const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDetailsV3.tagList)
  return _internal_taglist(index);
}
inline std::string* SongDetailsV3::mutable_taglist(int index) {
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongDetailsV3.tagList)
  return _impl_.taglist_.Mutable(index);
}
inline void SongDetailsV3::set_taglist(int index, const std::string& value) {
  _impl_.taglist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::set_taglist(int index, std::string&& value) {
  _impl_.taglist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::set_taglist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.taglist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::set_taglist(int index, const char* value, size_t size) {
  _impl_.taglist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline std::string* SongDetailsV3::_internal_add_taglist() {
  return _impl_.taglist_.Add();
}
inline void SongDetailsV3::add_taglist(const std::string& value) {
  _impl_.taglist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::add_taglist(std::string&& value) {
  _impl_.taglist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::add_taglist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.taglist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline void SongDetailsV3::add_taglist(const char* value, size_t size) {
  _impl_.taglist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SongDetailsCache.Structs.SongDetailsV3.tagList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SongDetailsV3::taglist() const {
  // @@protoc_insertion_point(field_list:SongDetailsCache.Structs.SongDetailsV3.tagList)
  return _impl_.taglist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SongDetailsV3::mutable_taglist() {
  // @@protoc_insertion_point(field_mutable_list:SongDetailsCache.Structs.SongDetailsV3.tagList)
  return &_impl_.taglist_;
}

// -------------------------------------------------------------------

// SongV3

// float bpm = 1;
inline void SongV3::clear_bpm() {
  _impl_.bpm_ = 0;
}
inline float SongV3::_internal_bpm() const {
  return _impl_.bpm_;
}
inline float SongV3::bpm() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.bpm)
  return _internal_bpm();
}
inline void SongV3::_internal_set_bpm(float value) {
  
  _impl_.bpm_ = value;
}
inline void SongV3::set_bpm(float value) {
  _internal_set_bpm(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.bpm)
}

// optional uint32 upvotes = 2;
inline bool SongV3::_internal_has_upvotes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SongV3::has_upvotes() const {
  return _internal_has_upvotes();
}
inline void SongV3::clear_upvotes() {
  _impl_.upvotes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SongV3::_internal_upvotes() const {
  return _impl_.upvotes_;
}
inline uint32_t SongV3::upvotes() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.upvotes)
  return _internal_upvotes();
}
inline void SongV3::_internal_set_upvotes(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.upvotes_ = value;
}
inline void SongV3::set_upvotes(uint32_t value) {
  _internal_set_upvotes(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.upvotes)
}

// optional uint32 downvotes = 3;
inline bool SongV3::_internal_has_downvotes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SongV3::has_downvotes() const {
  return _internal_has_downvotes();
}
inline void SongV3::clear_downvotes() {
  _impl_.downvotes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SongV3::_internal_downvotes() const {
  return _impl_.downvotes_;
}
inline uint32_t SongV3::downvotes() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.downvotes)
  return _internal_downvotes();
}
inline void SongV3::_internal_set_downvotes(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.downvotes_ = value;
}
inline void SongV3::set_downvotes(uint32_t value) {
  _internal_set_downvotes(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.downvotes)
}

// uint32 uploadTimeUnix = 4;
inline void SongV3::clear_uploadtimeunix() {
  _impl_.uploadtimeunix_ = 0u;
}
inline uint32_t SongV3::_internal_uploadtimeunix() const {
  return _impl_.uploadtimeunix_;
}
inline uint32_t SongV3::uploadtimeunix() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.uploadTimeUnix)
  return _internal_uploadtimeunix();
}
inline void SongV3::_internal_set_uploadtimeunix(uint32_t value) {
  
  _impl_.uploadtimeunix_ = value;
}
inline void SongV3::set_uploadtimeunix(uint32_t value) {
  _internal_set_uploadtimeunix(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.uploadTimeUnix)
}

// uint32 mapId = 5;
inline void SongV3::clear_mapid() {
  _impl_.mapid_ = 0u;
}
inline uint32_t SongV3::_internal_mapid() const {
  return _impl_.mapid_;
}
inline uint32_t SongV3::mapid() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.mapId)
  return _internal_mapid();
}
inline void SongV3::_internal_set_mapid(uint32_t value) {
  
  _impl_.mapid_ = value;
}
inline void SongV3::set_mapid(uint32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.mapId)
}

// optional uint32 songDurationSeconds = 6;
inline bool SongV3::_internal_has_songdurationseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SongV3::has_songdurationseconds() const {
  return _internal_has_songdurationseconds();
}
inline void SongV3::clear_songdurationseconds() {
  _impl_.songdurationseconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SongV3::_internal_songdurationseconds() const {
  return _impl_.songdurationseconds_;
}
inline uint32_t SongV3::songdurationseconds() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.songDurationSeconds)
  return _internal_songdurationseconds();
}
inline void SongV3::_internal_set_songdurationseconds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.songdurationseconds_ = value;
}
inline void SongV3::set_songdurationseconds(uint32_t value) {
  _internal_set_songdurationseconds(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.songDurationSeconds)
}

// string songName = 7;
inline void SongV3::clear_songname() {
  _impl_.songname_.ClearToEmpty();
}
inline const std::string& SongV3::songname() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.songName)
  return _internal_songname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongV3::set_songname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.songname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.songName)
}
inline std::string* SongV3::mutable_songname() {
  std::string* _s = _internal_mutable_songname();
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongV3.songName)
  return _s;
}
inline const std::string& SongV3::_internal_songname() const {
  return _impl_.songname_.Get();
}
inline void SongV3::_internal_set_songname(const std::string& value) {
  
  _impl_.songname_.Set(value, GetArenaForAllocation());
}
inline std::string* SongV3::_internal_mutable_songname() {
  
  return _impl_.songname_.Mutable(GetArenaForAllocation());
}
inline std::string* SongV3::release_songname() {
  // @@protoc_insertion_point(field_release:SongDetailsCache.Structs.SongV3.songName)
  return _impl_.songname_.Release();
}
inline void SongV3::set_allocated_songname(std::string* songname) {
  if (songname != nullptr) {
    
  } else {
    
  }
  _impl_.songname_.SetAllocated(songname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.songname_.IsDefault()) {
    _impl_.songname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SongDetailsCache.Structs.SongV3.songName)
}

// string songAuthorName = 8;
inline void SongV3::clear_songauthorname() {
  _impl_.songauthorname_.ClearToEmpty();
}
inline const std::string& SongV3::songauthorname() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.songAuthorName)
  return _internal_songauthorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongV3::set_songauthorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.songauthorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.songAuthorName)
}
inline std::string* SongV3::mutable_songauthorname() {
  std::string* _s = _internal_mutable_songauthorname();
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongV3.songAuthorName)
  return _s;
}
inline const std::string& SongV3::_internal_songauthorname() const {
  return _impl_.songauthorname_.Get();
}
inline void SongV3::_internal_set_songauthorname(const std::string& value) {
  
  _impl_.songauthorname_.Set(value, GetArenaForAllocation());
}
inline std::string* SongV3::_internal_mutable_songauthorname() {
  
  return _impl_.songauthorname_.Mutable(GetArenaForAllocation());
}
inline std::string* SongV3::release_songauthorname() {
  // @@protoc_insertion_point(field_release:SongDetailsCache.Structs.SongV3.songAuthorName)
  return _impl_.songauthorname_.Release();
}
inline void SongV3::set_allocated_songauthorname(std::string* songauthorname) {
  if (songauthorname != nullptr) {
    
  } else {
    
  }
  _impl_.songauthorname_.SetAllocated(songauthorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.songauthorname_.IsDefault()) {
    _impl_.songauthorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SongDetailsCache.Structs.SongV3.songAuthorName)
}

// string levelAuthorName = 9;
inline void SongV3::clear_levelauthorname() {
  _impl_.levelauthorname_.ClearToEmpty();
}
inline const std::string& SongV3::levelauthorname() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.levelAuthorName)
  return _internal_levelauthorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongV3::set_levelauthorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.levelauthorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.levelAuthorName)
}
inline std::string* SongV3::mutable_levelauthorname() {
  std::string* _s = _internal_mutable_levelauthorname();
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongV3.levelAuthorName)
  return _s;
}
inline const std::string& SongV3::_internal_levelauthorname() const {
  return _impl_.levelauthorname_.Get();
}
inline void SongV3::_internal_set_levelauthorname(const std::string& value) {
  
  _impl_.levelauthorname_.Set(value, GetArenaForAllocation());
}
inline std::string* SongV3::_internal_mutable_levelauthorname() {
  
  return _impl_.levelauthorname_.Mutable(GetArenaForAllocation());
}
inline std::string* SongV3::release_levelauthorname() {
  // @@protoc_insertion_point(field_release:SongDetailsCache.Structs.SongV3.levelAuthorName)
  return _impl_.levelauthorname_.Release();
}
inline void SongV3::set_allocated_levelauthorname(std::string* levelauthorname) {
  if (levelauthorname != nullptr) {
    
  } else {
    
  }
  _impl_.levelauthorname_.SetAllocated(levelauthorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.levelauthorname_.IsDefault()) {
    _impl_.levelauthorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SongDetailsCache.Structs.SongV3.levelAuthorName)
}

// optional string uploaderName = 10;
inline bool SongV3::_internal_has_uploadername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SongV3::has_uploadername() const {
  return _internal_has_uploadername();
}
inline void SongV3::clear_uploadername() {
  _impl_.uploadername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SongV3::uploadername() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.uploaderName)
  return _internal_uploadername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongV3::set_uploadername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uploadername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.uploaderName)
}
inline std::string* SongV3::mutable_uploadername() {
  std::string* _s = _internal_mutable_uploadername();
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongV3.uploaderName)
  return _s;
}
inline const std::string& SongV3::_internal_uploadername() const {
  return _impl_.uploadername_.Get();
}
inline void SongV3::_internal_set_uploadername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uploadername_.Set(value, GetArenaForAllocation());
}
inline std::string* SongV3::_internal_mutable_uploadername() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uploadername_.Mutable(GetArenaForAllocation());
}
inline std::string* SongV3::release_uploadername() {
  // @@protoc_insertion_point(field_release:SongDetailsCache.Structs.SongV3.uploaderName)
  if (!_internal_has_uploadername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uploadername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uploadername_.IsDefault()) {
    _impl_.uploadername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongV3::set_allocated_uploadername(std::string* uploadername) {
  if (uploadername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uploadername_.SetAllocated(uploadername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uploadername_.IsDefault()) {
    _impl_.uploadername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SongDetailsCache.Structs.SongV3.uploaderName)
}

// repeated .SongDetailsCache.Structs.SongDifficulty difficulties = 11;
inline int SongV3::_internal_difficulties_size() const {
  return _impl_.difficulties_.size();
}
inline int SongV3::difficulties_size() const {
  return _internal_difficulties_size();
}
inline void SongV3::clear_difficulties() {
  _impl_.difficulties_.Clear();
}
inline ::SongDetailsCache::Structs::SongDifficulty* SongV3::mutable_difficulties(int index) {
  // @@protoc_insertion_point(field_mutable:SongDetailsCache.Structs.SongV3.difficulties)
  return _impl_.difficulties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongDifficulty >*
SongV3::mutable_difficulties() {
  // @@protoc_insertion_point(field_mutable_list:SongDetailsCache.Structs.SongV3.difficulties)
  return &_impl_.difficulties_;
}
inline const ::SongDetailsCache::Structs::SongDifficulty& SongV3::_internal_difficulties(int index) const {
  return _impl_.difficulties_.Get(index);
}
inline const ::SongDetailsCache::Structs::SongDifficulty& SongV3::difficulties(int index) const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.difficulties)
  return _internal_difficulties(index);
}
inline ::SongDetailsCache::Structs::SongDifficulty* SongV3::_internal_add_difficulties() {
  return _impl_.difficulties_.Add();
}
inline ::SongDetailsCache::Structs::SongDifficulty* SongV3::add_difficulties() {
  ::SongDetailsCache::Structs::SongDifficulty* _add = _internal_add_difficulties();
  // @@protoc_insertion_point(field_add:SongDetailsCache.Structs.SongV3.difficulties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SongDetailsCache::Structs::SongDifficulty >&
SongV3::difficulties() const {
  // @@protoc_insertion_point(field_list:SongDetailsCache.Structs.SongV3.difficulties)
  return _impl_.difficulties_;
}

// optional uint32 rankedChangeUnix = 12;
inline bool SongV3::_internal_has_rankedchangeunix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SongV3::has_rankedchangeunix() const {
  return _internal_has_rankedchangeunix();
}
inline void SongV3::clear_rankedchangeunix() {
  _impl_.rankedchangeunix_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SongV3::_internal_rankedchangeunix() const {
  return _impl_.rankedchangeunix_;
}
inline uint32_t SongV3::rankedchangeunix() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.rankedChangeUnix)
  return _internal_rankedchangeunix();
}
inline void SongV3::_internal_set_rankedchangeunix(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rankedchangeunix_ = value;
}
inline void SongV3::set_rankedchangeunix(uint32_t value) {
  _internal_set_rankedchangeunix(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.rankedChangeUnix)
}

// optional .SongDetailsCache.Structs.RankedStatusBitflags rankedStateBitflags = 13;
inline bool SongV3::_internal_has_rankedstatebitflags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SongV3::has_rankedstatebitflags() const {
  return _internal_has_rankedstatebitflags();
}
inline void SongV3::clear_rankedstatebitflags() {
  _impl_.rankedstatebitflags_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::SongDetailsCache::Structs::RankedStatusBitflags SongV3::_internal_rankedstatebitflags() const {
  return static_cast< ::SongDetailsCache::Structs::RankedStatusBitflags >(_impl_.rankedstatebitflags_);
}
inline ::SongDetailsCache::Structs::RankedStatusBitflags SongV3::rankedstatebitflags() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.rankedStateBitflags)
  return _internal_rankedstatebitflags();
}
inline void SongV3::_internal_set_rankedstatebitflags(::SongDetailsCache::Structs::RankedStatusBitflags value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.rankedstatebitflags_ = value;
}
inline void SongV3::set_rankedstatebitflags(::SongDetailsCache::Structs::RankedStatusBitflags value) {
  _internal_set_rankedstatebitflags(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.rankedStateBitflags)
}

// optional uint64 tags = 14;
inline bool SongV3::_internal_has_tags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SongV3::has_tags() const {
  return _internal_has_tags();
}
inline void SongV3::clear_tags() {
  _impl_.tags_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t SongV3::_internal_tags() const {
  return _impl_.tags_;
}
inline uint64_t SongV3::tags() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.tags)
  return _internal_tags();
}
inline void SongV3::_internal_set_tags(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tags_ = value;
}
inline void SongV3::set_tags(uint64_t value) {
  _internal_set_tags(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.tags)
}

// optional .SongDetailsCache.Structs.UploadFlags uploadFlags = 15;
inline bool SongV3::_internal_has_uploadflags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SongV3::has_uploadflags() const {
  return _internal_has_uploadflags();
}
inline void SongV3::clear_uploadflags() {
  _impl_.uploadflags_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::SongDetailsCache::Structs::UploadFlags SongV3::_internal_uploadflags() const {
  return static_cast< ::SongDetailsCache::Structs::UploadFlags >(_impl_.uploadflags_);
}
inline ::SongDetailsCache::Structs::UploadFlags SongV3::uploadflags() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongV3.uploadFlags)
  return _internal_uploadflags();
}
inline void SongV3::_internal_set_uploadflags(::SongDetailsCache::Structs::UploadFlags value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.uploadflags_ = value;
}
inline void SongV3::set_uploadflags(::SongDetailsCache::Structs::UploadFlags value) {
  _internal_set_uploadflags(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongV3.uploadFlags)
}

// -------------------------------------------------------------------

// SongDifficulty

// optional .SongDetailsCache.Structs.SongDifficulty.MapCharacteristic characteristic = 1;
inline bool SongDifficulty::_internal_has_characteristic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SongDifficulty::has_characteristic() const {
  return _internal_has_characteristic();
}
inline void SongDifficulty::clear_characteristic() {
  _impl_.characteristic_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic SongDifficulty::_internal_characteristic() const {
  return static_cast< ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic >(_impl_.characteristic_);
}
inline ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic SongDifficulty::characteristic() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.characteristic)
  return _internal_characteristic();
}
inline void SongDifficulty::_internal_set_characteristic(::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.characteristic_ = value;
}
inline void SongDifficulty::set_characteristic(::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic value) {
  _internal_set_characteristic(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.characteristic)
}

// optional .SongDetailsCache.Structs.SongDifficulty.MapDifficulty difficulty = 2;
inline bool SongDifficulty::_internal_has_difficulty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SongDifficulty::has_difficulty() const {
  return _internal_has_difficulty();
}
inline void SongDifficulty::clear_difficulty() {
  _impl_.difficulty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty SongDifficulty::_internal_difficulty() const {
  return static_cast< ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty >(_impl_.difficulty_);
}
inline ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty SongDifficulty::difficulty() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.difficulty)
  return _internal_difficulty();
}
inline void SongDifficulty::_internal_set_difficulty(::SongDetailsCache::Structs::SongDifficulty_MapDifficulty value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.difficulty_ = value;
}
inline void SongDifficulty::set_difficulty(::SongDetailsCache::Structs::SongDifficulty_MapDifficulty value) {
  _internal_set_difficulty(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.difficulty)
}

// optional uint32 starsT100 = 4;
inline bool SongDifficulty::_internal_has_starst100() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SongDifficulty::has_starst100() const {
  return _internal_has_starst100();
}
inline void SongDifficulty::clear_starst100() {
  _impl_.starst100_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SongDifficulty::_internal_starst100() const {
  return _impl_.starst100_;
}
inline uint32_t SongDifficulty::starst100() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.starsT100)
  return _internal_starst100();
}
inline void SongDifficulty::_internal_set_starst100(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.starst100_ = value;
}
inline void SongDifficulty::set_starst100(uint32_t value) {
  _internal_set_starst100(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.starsT100)
}

// optional uint32 starsT100BL = 5;
inline bool SongDifficulty::_internal_has_starst100bl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SongDifficulty::has_starst100bl() const {
  return _internal_has_starst100bl();
}
inline void SongDifficulty::clear_starst100bl() {
  _impl_.starst100bl_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SongDifficulty::_internal_starst100bl() const {
  return _impl_.starst100bl_;
}
inline uint32_t SongDifficulty::starst100bl() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.starsT100BL)
  return _internal_starst100bl();
}
inline void SongDifficulty::_internal_set_starst100bl(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.starst100bl_ = value;
}
inline void SongDifficulty::set_starst100bl(uint32_t value) {
  _internal_set_starst100bl(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.starsT100BL)
}

// uint32 njsT100 = 6;
inline void SongDifficulty::clear_njst100() {
  _impl_.njst100_ = 0u;
}
inline uint32_t SongDifficulty::_internal_njst100() const {
  return _impl_.njst100_;
}
inline uint32_t SongDifficulty::njst100() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.njsT100)
  return _internal_njst100();
}
inline void SongDifficulty::_internal_set_njst100(uint32_t value) {
  
  _impl_.njst100_ = value;
}
inline void SongDifficulty::set_njst100(uint32_t value) {
  _internal_set_njst100(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.njsT100)
}

// optional uint32 bombs = 7;
inline bool SongDifficulty::_internal_has_bombs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SongDifficulty::has_bombs() const {
  return _internal_has_bombs();
}
inline void SongDifficulty::clear_bombs() {
  _impl_.bombs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SongDifficulty::_internal_bombs() const {
  return _impl_.bombs_;
}
inline uint32_t SongDifficulty::bombs() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.bombs)
  return _internal_bombs();
}
inline void SongDifficulty::_internal_set_bombs(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bombs_ = value;
}
inline void SongDifficulty::set_bombs(uint32_t value) {
  _internal_set_bombs(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.bombs)
}

// optional uint32 notes = 8;
inline bool SongDifficulty::_internal_has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SongDifficulty::has_notes() const {
  return _internal_has_notes();
}
inline void SongDifficulty::clear_notes() {
  _impl_.notes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t SongDifficulty::_internal_notes() const {
  return _impl_.notes_;
}
inline uint32_t SongDifficulty::notes() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.notes)
  return _internal_notes();
}
inline void SongDifficulty::_internal_set_notes(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.notes_ = value;
}
inline void SongDifficulty::set_notes(uint32_t value) {
  _internal_set_notes(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.notes)
}

// optional uint32 obstacles = 9;
inline bool SongDifficulty::_internal_has_obstacles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SongDifficulty::has_obstacles() const {
  return _internal_has_obstacles();
}
inline void SongDifficulty::clear_obstacles() {
  _impl_.obstacles_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t SongDifficulty::_internal_obstacles() const {
  return _impl_.obstacles_;
}
inline uint32_t SongDifficulty::obstacles() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.obstacles)
  return _internal_obstacles();
}
inline void SongDifficulty::_internal_set_obstacles(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.obstacles_ = value;
}
inline void SongDifficulty::set_obstacles(uint32_t value) {
  _internal_set_obstacles(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.obstacles)
}

// optional uint32 mods = 10;
inline bool SongDifficulty::_internal_has_mods() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SongDifficulty::has_mods() const {
  return _internal_has_mods();
}
inline void SongDifficulty::clear_mods() {
  _impl_.mods_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t SongDifficulty::_internal_mods() const {
  return _impl_.mods_;
}
inline uint32_t SongDifficulty::mods() const {
  // @@protoc_insertion_point(field_get:SongDetailsCache.Structs.SongDifficulty.mods)
  return _internal_mods();
}
inline void SongDifficulty::_internal_set_mods(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.mods_ = value;
}
inline void SongDifficulty::set_mods(uint32_t value) {
  _internal_set_mods(value);
  // @@protoc_insertion_point(field_set:SongDetailsCache.Structs.SongDifficulty.mods)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Structs
}  // namespace SongDetailsCache

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic>() {
  return ::SongDetailsCache::Structs::SongDifficulty_MapCharacteristic_descriptor();
}
template <> struct is_proto_enum< ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty>() {
  return ::SongDetailsCache::Structs::SongDifficulty_MapDifficulty_descriptor();
}
template <> struct is_proto_enum< ::SongDetailsCache::Structs::RankedStatusBitflags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongDetailsCache::Structs::RankedStatusBitflags>() {
  return ::SongDetailsCache::Structs::RankedStatusBitflags_descriptor();
}
template <> struct is_proto_enum< ::SongDetailsCache::Structs::UploadFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongDetailsCache::Structs::UploadFlags>() {
  return ::SongDetailsCache::Structs::UploadFlags_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SongProto_2eproto
